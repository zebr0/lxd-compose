#!/usr/bin/python3 -u

import argparse

import requests_unixsocket

api_url = "http+unix://%2Fvar%2Flib%2Flxd%2Funix.socket"
# opens a unix socket session for the rest of the script
session = requests_unixsocket.Session()


# this "hook" will be executed after each request to allow some generic treatment of the response
# see http://docs.python-requests.org/en/master/user/advanced/#event-hooks
def hook(response, **kwargs):
    json = response.json()
    type = json.get("type")

    if type == "error":
        raise Exception(json)

    # this will wait for lxd asynchronous operations to be finished
    # see https://github.com/lxc/lxd/blob/master/doc/rest-api.md#background-operation
    if type == "async":
        return session.get(api_url + json.get("operation") + "/wait")


session.hooks['response'].append(hook)


# parent (abstract) class for all lxd resources
class Resource:
    def __init__(self, collection_url, name):
        # relative api url for this type of lxd resource (for example: "/1.0/containers")
        self._collection_url = collection_url
        # the name of this specific resource
        self._name = name

    # returns the full api url for this type of lxd resource
    def get_full_collection_url(self):
        return api_url + self._collection_url

    # returns the full api url for this specific resource
    def get_full_element_url(self):
        return self.get_full_collection_url() + "/" + self._name

    # returns whether this specific resource exists or not...
    def exists(self):
        # by checking if the resource's name is listed in the response of the collection url
        return any(filter(
            lambda a: a == self._collection_url + "/" + self._name,
            session.get(self.get_full_collection_url()).json().get("metadata")
        ))

    # meant to be called by actual "create" functions in child classes with a json template matching the resource's type
    # handles the basic api resource creation
    def _create(self, json):
        # only does something if the resource doesn't already exist (idempotence)
        if not self.exists():
            print("creating", self._collection_url, self._name)
            session.post(self.get_full_collection_url(), json=json)
            if not self.exists():
                raise Exception("resource creation failed")

    # deletes this specific resource
    def delete(self):
        # only does something if the resource exists (idempotence)
        if self.exists():
            print("deleting", self._collection_url, self._name)
            session.delete(self.get_full_element_url())
            if self.exists():
                raise Exception("resource deletion failed")


class Network(Resource):
    def __init__(self, project, config):
        # network names must end with a digit
        super().__init__("/1.0/networks", project + "0")

        # additional attributes
        self._address = config.get("network_address")
        self._domain = project

    def create(self):
        super()._create({
            "name": self._name,
            "config": {
                "ipv4.address": self._address,
                "ipv4.nat": "true",
                "ipv6.address": "none",
                "dns.mode": "dynamic",
                "dns.domain": self._domain
            }
        })


class Profile(Resource):
    def __init__(self, project):
        super().__init__("/1.0/profiles", project)

        # additional attribute: reference to the corresponding network
        self._network = project + "0"

    def create(self):
        super()._create({
            "name": self._name,
            "devices": {
                "eth0": {
                    "type": "nic",
                    "nictype": "bridged",
                    "parent": self._network
                }
            }
        })


class Container(Resource):
    def __init__(self, type, project, stage):
        # the container name is a concatenation of its type, the project name and the deployment stage
        super().__init__("/1.0/containers", "-".join([type, project, stage]))

        # additional attribute: reference to the project's profile
        self._profile = project

    def create(self):
        super()._create({
            "name": self._name,
            "profiles": ["default", "compose", self._profile],
            "source": {
                "type": "image",
                "mode": "pull",
                "server": "https://images.linuxcontainers.org",
                "protocol": "simplestreams",
                "alias": "ubuntu/xenial"
            }
        })

    # returns whether this specific container is running or not...
    def is_running(self):
        # by checking its status in the metadata
        return self.exists() and session.get(self.get_full_element_url()).json().get("metadata").get(
            "status") == "Running"

    # starts this specific container
    def start(self):
        if not self.exists():
            raise Exception("container starting failed: container must exist")

        # only does something if the resource isn't already running (idempotence)
        if not self.is_running():
            print("starting", self._collection_url, self._name)
            session.put(self.get_full_element_url() + "/state", json={"action": "start"})
            if not self.is_running():
                raise Exception("container starting failed")

    # stops this specific container
    def stop(self):
        if not self.exists():
            raise Exception("container stopping failed: container must exist")

        # only does something if the resource is running (idempotence)
        if self.is_running():
            print("stopping", self._collection_url, self._name)
            session.put(self.get_full_element_url() + "/state", json={"action": "stop"})
            if self.is_running():
                raise Exception("container stopping failed")


project_config = {
    "network_address": "10.42.254.1/24",
    "containers": ["dummy"]
}


def create(args):
    Network(args.project, project_config).create()
    Profile(args.project).create()
    for type in project_config.get("containers"):
        Container(type, args.project, args.stage).create()


def start(args):
    for type in project_config.get("containers"):
        Container(type, args.project, args.stage).start()


def stop(args):
    for type in project_config.get("containers"):
        Container(type, args.project, args.stage).stop()


def delete(args):
    for type in project_config.get("containers"):
        container = Container(type, args.project, args.stage)
        container.stop()
        container.delete()
    Profile(args.project).delete()
    Network(args.project, project_config).delete()


argparser = argparse.ArgumentParser()
subparsers = argparser.add_subparsers()

parser_create = subparsers.add_parser("create")
parser_create.add_argument("project")
parser_create.add_argument("stage")
parser_create.set_defaults(func=create)

parser_start = subparsers.add_parser("start")
parser_start.add_argument("project")
parser_start.add_argument("stage")
parser_start.set_defaults(func=start)

parser_stop = subparsers.add_parser("stop")
parser_stop.add_argument("project")
parser_stop.add_argument("stage")
parser_stop.set_defaults(func=stop)

parser_delete = subparsers.add_parser("delete")
parser_delete.add_argument("project")
parser_delete.add_argument("stage")
parser_delete.set_defaults(func=delete)

args = argparser.parse_args()
args.func(args)

session.close()
