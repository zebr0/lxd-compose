#!/usr/bin/python3 -u

import argparse
import sys

import requests_unixsocket
import yaml


# parent (abstract) class for all lxd resources
class Resource:
    def __init__(self, collection_url, config):
        # relative api url for this type of lxd resource (for example: "/1.0/containers")
        self._collection_url = collection_url
        # the configuration of this specific resource
        self._config = config

    def get_name(self):
        return self._config.get("name")

    # returns the full api url for this type of lxd resource
    def get_full_collection_url(self):
        return api_url + self._collection_url

    # returns the full api url for this specific resource
    def get_full_element_url(self):
        return self.get_full_collection_url() + "/" + self.get_name()

    # returns whether this specific resource exists or not...
    def exists(self):
        # by checking if the resource's name is listed in the response of the collection url
        return any(filter(
            lambda a: a == self._collection_url + "/" + self.get_name(),
            session.get(self.get_full_collection_url()).json().get("metadata")
        ))

    # creates this specific resource
    def create(self):
        # only does something if the resource doesn't already exist (idempotence)
        if not self.exists():
            print("creating", self._collection_url, self.get_name())
            session.post(self.get_full_collection_url(), json=self._config)
            if not self.exists():
                raise Exception("resource creation failed")

    # deletes this specific resource
    def delete(self):
        # only does something if the resource exists (idempotence)
        if self.exists():
            print("deleting", self._collection_url, self.get_name())
            session.delete(self.get_full_element_url())
            if self.exists():
                raise Exception("resource deletion failed")


class StoragePool(Resource):
    def __init__(self, config):
        super().__init__("/1.0/storage-pools", config)


class Network(Resource):
    def __init__(self, config):
        super().__init__("/1.0/networks", config)


class Profile(Resource):
    def __init__(self, config):
        super().__init__("/1.0/profiles", config)


class Container(Resource):
    def __init__(self, config):
        super().__init__("/1.0/containers", config)

    # returns whether this specific container is running or not...
    def is_running(self):
        # by checking its status in the metadata
        return self.exists() and session.get(self.get_full_element_url()).json().get("metadata").get(
            "status") == "Running"

    # starts this specific container
    def start(self):
        if not self.exists():
            raise Exception("container starting failed: container must exist")

        # only does something if the resource isn't already running (idempotence)
        if not self.is_running():
            print("starting", self._collection_url, self.get_name())
            session.put(self.get_full_element_url() + "/state", json={"action": "start"})
            if not self.is_running():
                raise Exception("container starting failed")

    # stops this specific container
    def stop(self):
        if not self.exists():
            raise Exception("container stopping failed: container must exist")

        # only does something if the resource is running (idempotence)
        if self.is_running():
            print("stopping", self._collection_url, self.get_name())
            session.put(self.get_full_element_url() + "/state", json={"action": "stop"})
            if self.is_running():
                raise Exception("container stopping failed")


def create():
    for item in config.get("storage-pools"):
        StoragePool(item).create()
    for item in config.get("networks"):
        Network(item).create()
    for item in config.get("profiles"):
        Profile(item).create()
    for item in config.get("containers"):
        Container(item).create()


def start():
    for item in config.get("containers"):
        Container(item).start()


def stop():
    for item in config.get("containers"):
        Container(item).stop()


def delete():
    for item in config.get("containers"):
        Container(item).delete()
    for item in config.get("profiles"):
        Profile(item).delete()
    for item in config.get("networks"):
        Network(item).delete()
    for item in config.get("storage-pools"):
        StoragePool(item).delete()


# this "hook" will be executed after each request to allow some generic treatment of the response
# see http://docs.python-requests.org/en/master/user/advanced/#event-hooks
def hook(response, **kwargs):
    json = response.json()
    type = json.get("type")

    if type == "error":
        raise Exception(json)

    # this will wait for lxd asynchronous operations to be finished
    # see https://github.com/lxc/lxd/blob/master/doc/rest-api.md#background-operation
    if type == "async":
        return session.get(api_url + json.get("operation") + "/wait")


# entrypoint
if __name__ == "__main__":
    # opens a unix socket session and adds the hook defined above
    session = requests_unixsocket.Session()
    session.hooks["response"].append(hook)
    api_url = "http+unix://%2Fvar%2Flib%2Flxd%2Funix.socket"

    argparser = argparse.ArgumentParser(description="Define and run multi-container applications with LXD.")
    argparser.add_argument("command", choices=["create", "start", "stop", "delete"],
                           help="command to execute on the configuration given through stdin")
    args = argparser.parse_args()

    # loads the configuration from stdin (uses the yaml baseloader to preserve all strings)
    config = yaml.load(sys.stdin, Loader=yaml.BaseLoader)

    # calls the method given as parameter
    globals()[args.command]()

    session.close()
